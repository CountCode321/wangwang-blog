(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{567:function(_,v,t){"use strict";t.r(v);var a=t(10),s=Object(a.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h2",{attrs:{id:"八、vue-router"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#八、vue-router"}},[_._v("#")]),_._v(" 八、vue-router")]),_._v(" "),t("p",[_._v("路由：通过互联的网络把信息从源地址传输到目的地址的活动。")]),_._v(" "),t("p",[t("strong",[_._v("路由器提供了两种机制: 路由和转送")])]),_._v(" "),t("ul",[t("li",[_._v("路由是决定数据包从"),t("strong",[_._v("来源到目的地")]),_._v("的路径")]),_._v(" "),t("li",[_._v("转送将"),t("strong",[_._v("输入端")]),_._v("的数据转移到合适的"),t("strong",[_._v("输出端")])])]),_._v(" "),t("p",[t("strong",[_._v("路由中有一个非常重要的概念叫路由表")])]),_._v(" "),t("ul",[t("li",[_._v("路由表本质上就是一个映射表, 决定了数据包的指向")]),_._v(" "),t("li",[_._v("映射表：【内网ip1：电脑MAC地址；....】")])]),_._v(" "),t("p",[t("strong",[_._v("什么是前端渲染，什么是后端渲染？")])]),_._v(" "),t("p",[_._v("答：后端渲染：服务端渲染；后端路由：处理URL和页面之间的映射关系；")]),_._v(" "),t("p",[_._v("前端渲染：浏览器中显示的网页中的大部分内容，都是由前端写的js代码在浏览器中执行，最终渲染出来的网页。")]),_._v(" "),t("h3",{attrs:{id:"后端路由-前端路由"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#后端路由-前端路由"}},[_._v("#")]),_._v(" 后端路由 + 前端路由")]),_._v(" "),t("h4",{attrs:{id:"后端路由"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#后端路由"}},[_._v("#")]),_._v(" 后端路由")]),_._v(" "),t("p",[_._v("服务器直接生产渲染好对应的HTML页面，返回给客户端进行展示。")]),_._v(" "),t("p",[_._v("缺点：HTML和数据逻辑混乱，编写和维护都很难。")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://img-blog.csdnimg.cn/f1f5bc7fdcc341bc8a48ab547f0bbc11.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiN5oCV56eD5aS055qE56iL5bqP5aqb,size_20,color_FFFFFF,t_70,g_se,x_16",alt:"在这里插入图片描述"}})]),_._v(" "),t("h4",{attrs:{id:"前后端分离阶段"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前后端分离阶段"}},[_._v("#")]),_._v(" 前后端分离阶段")]),_._v(" "),t("p",[_._v("ajax的出现。")]),_._v(" "),t("p",[_._v("后端只提供API来返回数据，不负责任何阶段的内容。")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://img-blog.csdnimg.cn/1a7e0909f1da418cb00f201d5a188bb6.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiN5oCV56eD5aS055qE56iL5bqP5aqb,size_20,color_FFFFFF,t_70,g_se,x_16",alt:"在这里插入图片描述"}})]),_._v(" "),t("p",[_._v("优势：后端专注于数据，前端专注于交互和可视化。")]),_._v(" "),t("h4",{attrs:{id:"前端路由"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前端路由"}},[_._v("#")]),_._v(" 前端路由")]),_._v(" "),t("p",[_._v("SPA页面（simple page application）")]),_._v(" "),t("p",[_._v("整个网页只有一个html页面")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://img-blog.csdnimg.cn/01749bfc80bc4b9f96b5db68bea17ef8.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiN5oCV56eD5aS055qE56iL5bqP5aqb,size_20,color_FFFFFF,t_70,g_se,x_16",alt:"在这里插入图片描述"}})]),_._v(" "),t("h4",{attrs:{id:"综合总结面试"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#综合总结面试"}},[_._v("#")]),_._v(" 综合总结面试")]),_._v(" "),t("p",[_._v("综合总结提问")]),_._v(" "),t("ol",[t("li",[t("h5",{attrs:{id:"什么是前端渲染-什么是后端渲染"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是前端渲染-什么是后端渲染"}},[_._v("#")]),_._v(" 什么是前端渲染, 什么是后端渲染?")])])]),_._v(" "),t("p",[t("strong",[_._v("前端渲染：")])]),_._v(" "),t("p",[_._v("指的是后端返回JSON数据，前端利用预先写的html模板，循环读取JSON数据，拼接字符串（es6的模板字符串特性大大减少了拼接字符串的的成本），并插入页面。")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("好处：网络传输数据量小。不占用服务端运算资源（解析模板），模板在前端（很有可能仅部分在前端），改结构变交互都前端自己来了，改完自己调就行。")])]),_._v(" "),t("li",[t("p",[_._v("坏处：前端耗时较多，对前端工作人员水平要求相对较高。前端代码较多，因为部分以前在后台处理的交互逻辑交给了前端处理。占用少部分客户端运算资源用于解析模板。")])])]),_._v(" "),t("p",[t("strong",[_._v("后端渲染：")])]),_._v(" "),t("p",[_._v("前端请求，后端用后台模板引擎直接生成html，前端接受到数据之后，直接插入页面。")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("好处：前端耗时少，即减少了首屏时间，模板统一在后端。前端（相对）省事，不占用客户端运算资源（解析模板）")])]),_._v(" "),t("li",[t("p",[_._v("坏处：占用服务器资源。")])])]),_._v(" "),t("h5",{attrs:{id:"前端渲染与后端渲染对比"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前端渲染与后端渲染对比"}},[_._v("#")]),_._v(" 前端渲染与后端渲染对比：")]),_._v(" "),t("p",[t("strong",[_._v("后端渲染：")]),_._v("\n页面呈现速度：快，受限于用户的带宽\n流量消耗：少一点点（可以省去前端框架部分的代码）\n可维护性：差（前后端东西放一起，掐架多年，早就在闹分手啦）\nseo友好度：好\n编码效率：低（这个跟不同的团队不同，可能不对）")]),_._v(" "),t("p",[t("strong",[_._v("前端渲染：")]),_._v("\n页面呈现速度：主要受限于带宽和客户端机器的好坏，优化的好，可以逐步动态展开内容，感觉上会更快一点")]),_._v(" "),t("p",[_._v("流量消耗：多一点点（一个前端框架大概50KB）当然，有的用后端渲染的项目前端部分也有在用框架")]),_._v(" "),t("p",[_._v("可维护性：好，前后端分离，各施其职，代码一目明了。\nSEO友好度：差，大量使用ajax，多数浏览器不能抓取ajax数据。\n编码效率：高，前后端各自只做自己擅长的东西，后端最后只输出接口，不用管页面呈现，只要前后端人员能力不错，效率不会低")]),_._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[t("h5",{attrs:{id:"什么是前后端分离"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是前后端分离"}},[_._v("#")]),_._v(" 什么是前后端分离")])])]),_._v(" "),t("p",[_._v("现在 Web 服务器不再处理任何业务，它接收到请求后，经过转换，发送给各个相关后端服务器，将各个后端服务器返回的，处理过的业务数据填入 HTML 模板，最后发送给浏览器。Web 服务器和后端服务器间，可以选用任何你觉得合适的通信手段，可以是 REST，可以是 RPC，选用什么样的通信手段，这是另一个议题了。")]),_._v(" "),t("p",[_._v("这样，前端人员和后端人员约定好接口后，前端人员彻底不用再关心业务处理是怎么回事，他只需要把界面做好就可以了，后端人员也不用再关系前端界面是什么样的，他只需要做好业务逻辑处理即可。服务的切离，代码管理，服务部署也都独立出来分别管理，系统的灵活性也获得了极大的提升。")]),_._v(" "),t("p",[_._v("注意，这不是个微服务架构，那是另外一个议题了")]),_._v(" "),t("p",[_._v("总结，任何系统架构设计，实际上是对组织结构在系统上进行映射，前后端分离，就是在对前端开发人员和后端开发人员的工作进行解耦，尽量减少他她们之间的交流成本，帮助他她们更能专注于自己擅长的工作。")]),_._v(" "),t("p",[_._v("最后是几个常见误解的说明：")]),_._v(" "),t("h5",{attrs:{id:"前后端分离是说浏览器和后端服务分离吗"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前后端分离是说浏览器和后端服务分离吗"}},[_._v("#")]),_._v(" 前后端分离是说浏览器和后端服务分离吗？")]),_._v(" "),t("p",[_._v("不是，前后端分离里的前端不是浏览器，指的是生成 HTML 的那个服务，它可以是一个仅仅生成 HTML 的 Web 服务器，也可以是在浏览器中通过 JS 动态生成 HTML 的 单页应用。实践中，有实力的团队往往在实现前后端分离里时，前端选用 node 服务器，后端选用 C#、Java 等（排名不分先后）")]),_._v(" "),t("h5",{attrs:{id:"前后端分离是种技术吗"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前后端分离是种技术吗"}},[_._v("#")]),_._v(" 前后端分离是种技术吗？")]),_._v(" "),t("p",[_._v("不是，前后端分离是种架构模式，或者说是最佳实践。所谓模式就是大家这么用了觉得不错，你可以直接抄来用的固定套路。")]),_._v(" "),t("h5",{attrs:{id:"前后端分离是最佳实践吗"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前后端分离是最佳实践吗"}},[_._v("#")]),_._v(" 前后端分离是最佳实践吗？")]),_._v(" "),t("p",[_._v("看你团队和项目的情况，如果是短平快的小项目，真的没必要。如果是面向简历开发，那绝对在任何时候都应该使用前后端分离这种架构。")]),_._v(" "),t("ol",{attrs:{start:"3"}},[t("li",[t("h5",{attrs:{id:"什么是前端路由-什么是后端路由"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是前端路由-什么是后端路由"}},[_._v("#")]),_._v(" 什么是前端路由, 什么是后端路由?")])])]),_._v(" "),t("p",[t("strong",[_._v("A. 什么是前端路由？")])]),_._v(" "),t("p",[_._v("很重要的一点是页面不刷新，前端路由就是把不同路由对应不同的内容或页面的任务交给前端来做，每跳转到不同的URL都是使用前端的锚点路由. 随着（SPA）单页应用的不断普及，前后端开发分离，目前项目基本都使用前端路由，在项目使用期间页面不会重新加载")]),_._v(" "),t("p",[t("strong",[_._v("B. 什么是后端路由？")])]),_._v(" "),t("p",[_._v("浏览器在地址栏中切换不同的url时，每次都向后台服务器发出请求，服务器响应请求，在后台拼接html文件传给前端显示, 返回不同的页面, 意味着浏览器会刷新页面，网速慢的话说不定屏幕全白再有新内容。后端路由的另外一个极大的问题就是 前后端不分离。")]),_._v(" "),t("p",[_._v("优点：分担了前端的压力，html和数据的拼接都是由服务器完成。")]),_._v(" "),t("p",[_._v("缺点：当项目十分庞大时，加大了服务器端的压力，同时在浏览器端不能输入制定的url路径进行指定模块的访问。另外一个就是如果当前网速过慢，那将会延迟页面的加载，对用户体验不是很友好。")]),_._v(" "),t("p",[t("strong",[_._v("C. 什么时候使用前端路由？")])]),_._v(" "),t("p",[_._v("在单页面应用，大部分页面结构不变，只改变部分内容的使用")]),_._v(" "),t("p",[t("strong",[_._v("D. 前端路由有什么优点和缺点？")])]),_._v(" "),t("p",[_._v("优点:")]),_._v(" "),t("p",[_._v("用户体验好，和后台网速没有关系，不需要每次都从服务器全部获取，快速展现给用户")]),_._v(" "),t("p",[_._v("可以再浏览器中输入指定想要访问的url路径地址。")]),_._v(" "),t("p",[_._v("实现了前后端的分离，方便开发。有很多框架都带有路由功能模块")]),_._v(" "),t("p",[_._v("缺点:")]),_._v(" "),t("p",[_._v("使用浏览器的前进，后退键的时候会重新发送请求，没有合理地利用缓存")]),_._v(" "),t("p",[_._v("单页面无法记住之前滚动的位置，无法在前进，后退的时候记住滚动的位置")])])}),[],!1,null,null,null);v.default=s.exports}}]);